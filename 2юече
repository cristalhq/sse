
var (
	headerHost       = "Host"
	headerUpgrade    = "Upgrade"
	headerConnection = "Connection"
	// headerSecVersion    = "Sec-WebSocket-Version"
	// headerSecProtocol   = "Sec-WebSocket-Protocol"
	// headerSecExtensions = "Sec-WebSocket-Extensions"
	// headerSecKey        = "Sec-WebSocket-Key"
	// headerSecAccept     = "Sec-WebSocket-Accept"
)

const (
	acceptSize   = 28 // base64.StdEncoding.EncodedLen(sha1.Size)
	nonceKeySize = 16
	nonceSize    = 24 // base64.StdEncoding.EncodedLen(nonceKeySize)
)

func writeAccept(bw *bufio.Writer, nonce []byte) (int, error) {
	accept := make([]byte, acceptSize)
	initAcceptFromNonce(accept, nonce)
	// NOTE: write accept bytes as a string to prevent heap allocation –
	// WriteString() copy given string into its inner buffer, unlike Write()
	// which may write p directly to the underlying io.Writer – which in turn
	// will lead to p escape.
	return bw.WriteString(b2s(accept))
}

func nonZero(a, b int) int {
	if a != 0 {
		return a
	}
	return b
}

// readLine reads line from br. It reads until '\n' and returns bytes without
// '\n' or '\r\n' at the end.
// It returns err if and only if line does not end in '\n'. Note that read
// bytes returned in any case of error.
//
// It is much like the textproto/Reader.ReadLine() except the thing that it
// returns raw bytes, instead of string. That is, it avoids copying bytes read
// from br.
//
// textproto/Reader.ReadLineBytes() is also makes copy of resulting bytes to be
// safe with future I/O operations on br.
//
// We could control I/O operations on br and do not need to make additional
// copy for safety.
//
// NOTE: it may return copied flag to notify that returned buffer is safe to
// use.
func readLine(br *bufio.Reader) ([]byte, error) {
	var line []byte
	for {
		bts, err := br.ReadSlice('\n')
		if err == bufio.ErrBufferFull {
			// Copy bytes because next read will discard them.
			line = append(line, bts...)
			continue
		}

		// Avoid copy of single read.
		if line == nil {
			line = bts
		} else {
			line = append(line, bts...)
		}
		if err != nil {
			return line, err
		}

		// Size of line is at least 1.
		// In other case bufio.ReadSlice() returns error.
		n := len(line)

		// Cut '\n' or '\r\n'.
		if n > 1 && line[n-2] == '\r' {
			line = line[:n-2]
		} else {
			line = line[:n-1]
		}
		return line, nil
	}
}

type httpRequestLine struct {
	method, uri  []byte
	major, minor int
}

// httpParseRequestLine parses http request line like "GET / HTTP/1.0".
func httpParseRequestLine(line []byte) (httpRequestLine, error) {
	var req httpRequestLine
	var proto []byte
	req.method, req.uri, proto = bsplit3(line, ' ')

	var ok bool
	req.major, req.minor, ok = httpParseVersion(proto)
	if !ok {
		return req, errors.New("ErrMalformedRequest")
	}
	return req, nil
}

var (
	httpVersion1_0    = []byte("HTTP/1.0")
	httpVersion1_1    = []byte("HTTP/1.1")
	httpVersion2      = []byte("HTTP/2")
	httpVersionPrefix = []byte("HTTP/")
)

// httpParseVersion parses major and minor version of HTTP protocol. It returns
// parsed values and true if parse is ok.
func httpParseVersion(buf []byte) (major, minor int, ok bool) {
	switch {
	case bytes.Equal(buf, httpVersion2):
		return 2, 0, true
	case bytes.Equal(buf, httpVersion1_0):
		return 1, 0, true
	case bytes.Equal(buf, httpVersion1_1):
		return 1, 1, true
	case len(buf) < 8:
		return 0, 0, false
	case !bytes.Equal(buf[:5], httpVersionPrefix):
		return 0, 0, false
	}
	buf = buf[5:]

	dot := bytes.IndexByte(buf, '.')
	if dot == -1 {
		return 0, 0, false
	}

	var err error
	major, err = asciiToInt(buf[:dot])
	if err != nil {
		return 0, 0, false
	}
	minor, err = asciiToInt(buf[dot+1:])
	if err != nil {
		return 0, 0, false
	}
	return major, minor, true
}

// httpParseHeaderLine parses HTTP header as key-value pair. It returns parsed
// values and true if parse is ok.
func httpParseHeaderLine(line []byte) (k, v []byte, ok bool) {
	colon := bytes.IndexByte(line, ':')
	if colon == -1 {
		return
	}

	k = btrim(line[:colon])
	// TODO(gobwas): maybe use just lower here?
	canonicalizeHeaderKey(k)

	v = btrim(line[colon+1:])

	return k, v, true
}

// Algorithm below is like standard textproto/CanonicalMIMEHeaderKey, except
// that it operates with slice of bytes and modifies it inplace without copying.
func canonicalizeHeaderKey(k []byte) {
	upper := true
	for i, c := range k {
		if upper && 'a' <= c && c <= 'z' {
			k[i] &= toUpper
		} else if !upper && 'A' <= c && c <= 'Z' {
			k[i] |= toLower
		}
		upper = c == '-'
	}
}

func httpWriteResponseError(bw *bufio.Writer, err error, code int) {
	switch code {
	case http.StatusBadRequest:
		bw.WriteString(textHeadBadRequest)
	case http.StatusInternalServerError:
		bw.WriteString(textHeadInternalServerError)
	case http.StatusUpgradeRequired:
		bw.WriteString(textHeadUpgradeRequired)
	default:
		writeStatusText(bw, code)
	}

	// Write custom headers.
	// if header != nil {
	// 	header(bw)
	// }

	switch err.Error() {
	case "ErrHandshakeBadProtocol":
		bw.WriteString(textTailErrHandshakeBadProtocol)
	case "ErrHandshakeBadMethod":
		bw.WriteString(textTailErrHandshakeBadMethod)
	case "ErrHandshakeBadHost":
		bw.WriteString(textTailErrHandshakeBadHost)
	case "ErrHandshakeBadUpgrade":
		bw.WriteString(textTailErrHandshakeBadUpgrade)
	case "ErrHandshakeBadConnection":
		bw.WriteString(textTailErrHandshakeBadConnection)
	case "ErrHandshakeBadSecAccept":
		bw.WriteString(textTailErrHandshakeBadSecAccept)
	case "ErrHandshakeBadSecKey":
		bw.WriteString(textTailErrHandshakeBadSecKey)
	case "ErrHandshakeBadSecVersion":
		bw.WriteString(textTailErrHandshakeBadSecVersion)
	case "ErrHandshakeUpgradeRequired":
		bw.WriteString(textTailErrUpgradeRequired)
	// case nil:
	// 	bw.WriteString(crlf)
	default:
		writeErrorText(bw, err)
	}
}

// statusText is a non-performant status text generator.
// NOTE: Used only to generate constants.
func statusText(code int) string {
	var buf bytes.Buffer
	bw := bufio.NewWriter(&buf)
	writeStatusText(bw, code)
	bw.Flush()
	return buf.String()
}

// initAcceptFromNonce fills given slice with accept bytes generated from given
// nonce bytes. Given buffer should be exactly acceptSize bytes.
func initAcceptFromNonce(accept, nonce []byte) {
	const magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

	if len(accept) != acceptSize {
		panic("accept buffer is invalid")
	}
	if len(nonce) != nonceSize {
		panic("nonce is invalid")
	}

	p := make([]byte, nonceSize+len(magic))
	copy(p[:nonceSize], nonce)
	copy(p[nonceSize:], magic)

	sum := sha1.Sum(p)
	base64.StdEncoding.Encode(accept, sum[:])
}
